#' @title Interpolate yield points of a single field
#' @description TODO
#' @param indata_sp points of a single field (with optional "idfield" attribute)
#' @param field_poly polygon of the field
#' @param vgm.fit variogram
#' @param globgrid grid generated by yield.makegrid()
#' @param method one between "krige" (default) and "idw"
#' @param n_cores 1 for singlecore (default), more for multicore, NA for multicore autodetection
#' @param focal_types smoothing filters to be applied (vector of types of focalWeight())
#' @param focal_d list of filter parameters (see argument d of focalWeight())
#' @param border border (in crs unit) to be cut (default: 0)
#' @param outdir directory where rasters are stores (default: temporary directory)
#' @param outname name of the output tif
#' @param samplesize maximum size of the sample of the original data to work with (default: 10000; if NA: all the points)
#' @param nmax argument of krige() and idw()
#' @param maxdist argument of krige() and idw()
#' @importFrom raster crop focal focalWeight raster
#' @importFrom rgdal writeGDAL
#' @importFrom rgeos gBuffer
#' @importFrom sp identicalCRS spTransform
#' @importFrom stringr str_pad
#' @importFrom methods as
#' @export
#' @author Luigi Ranghetti, phD (2018) \email{ranghetti.l@@irea.cnr.it}
#' @note License: GPL 3.0

interp.yieldpoints <- function(
  indata_sp, # points of a single field (with optional "idfield" attribute)
  field_poly, # polygon of the field
  vgm.fit, # variogram
  globgrid, # grid generated by yield.makegrid()
  method = "krige", # one between "krige" and "idw"
  n_cores = 1, # 1 for singlecore, more for multicore, NA for multicore autodetection
  focal_types = NULL, # smoothing filters to be applied (vector of types of focalWeight())
  focal_d = NULL, # list of filter parameters (of)see argument d of focalWeight())
  border = 0, # border (in crs unit) to be cut
  outdir = tempdir(), # directory where rasters are stores
  outname = NA, # name of the output tif
  samplesize=1E4, # maximum size of the sample of the original data to work with (default: 10000; if NA: all the points)
  nmax=1E3, # argument of krige() and idw()
  maxdist=Inf # argument of krige() and idw()
) {

  # Checks

  # check that idfield is unique
  if ("idfield" %in% names(indata_sp)) {
    sel_idfield <- unique(indata_sp$idfield)
    if (length(sel_idfield)>1) {
      stop("Error: idfield attribute must contain only one value.")
    }
  } else {
    sel_idfield <- NA
  }
  # for now, no checks are performed on "idfield" attribute in field_poly
  # (the function assumes that field_poly contains only the geometry of sel_idfield)

  # check field_poly crs
  if (!identicalCRS(field_poly,globgrid)) {
    field_poly <- spTransform(field_poly,globgrid@proj4string)
  }
  # check indata_sp crs
  if (!identicalCRS(indata_sp,globgrid)) {
    indata_sp <- spTransform(indata_sp,globgrid@proj4string)
  }

  # yield_r <- list()
  # # cycle on single paddies
  # for (field_id in unique(indata_sp$idfield)) {

  # subsample
  if (is.na(samplesize)) {
    samplesize <- length(indata_sp)
  }
  if (samplesize<length(indata_sp)) {
    indata_sp_sub <- indata_sp[indata_sp$sid<=samplesize,]
  } else {
    indata_sp_sub <- indata_sp
  }

  # crop grid on field_poly extent
  if (!is.null(focal_d)) {
    d_buffer <- max(c(sapply(focal_d, max),unlist(focal_d[focal_types=="Gauss"])*3))
  } else {
    d_buffer <- 3
  }
  # cut on borders ("buffer" value plus half of raster resolution, to cut pixels of border)
  yieldgrid <- as(crop(raster(globgrid), field_poly), "SpatialPixels")
  yieldgrid <- yieldgrid[gBuffer(field_poly,width=-(border+globgrid@grid@cellsize[1]/2)),]
  # create buffered grid (for focals)
  field_poly_buf <- gBuffer(field_poly, width=globgrid@grid@cellsize[1]*d_buffer)
  yieldgrid_buf <- as(crop(raster(globgrid), field_poly_buf), "SpatialPixelsDataFrame")
  yieldgrid_buf <- yieldgrid_buf[field_poly_buf,]


  # TODO use spatialpixels and exclude areas from buffer polygon

  # interpolate
  interp_raster <- krige_par(yield ~ 1, indata_sp_sub, yieldgrid, vgm.fit, method=method, n_cores=n_cores, maxdist=maxdist)
  # cut on borders ("buffer" value plus half of raster resolution, to cut pixels of border)
  crop_raster <- interp_raster[gBuffer(field_poly,width=-(border+globgrid@grid@cellsize[1]/2)),]

  # export raster
  if (is.na(outname)) {
    if (is.na(sel_idfield)) {
      outname <- paste0('yield_',stringr::str_pad(sample(1E4,1),4,"left","0"),'.tif')
    } else {
      outname <- paste0('yield_',sel_idfield,'.tif')
    }
  }

  dir.create(file.path(outdir,"interp"), recursive=TRUE, showWarnings=FALSE)
  writeGDAL(crop_raster["var1.pred"],file.path(outdir,"interp",outname), options='COMPRESS=DEFLATE')
  print(file.path(outdir,outname))

  # extend interp grid, using average value as NA
  # raster_crop_pred <- raster(interp_raster["var1.pred"])
  # raster_crop_var <- raster(interp_raster["var1.var"])
  raster_crop_pred_avg <- yieldgrid_buf
  raster_crop_pred_avg$band1 <- mean(interp_raster$var1.pred, na.rm=TRUE)
  raster_crop_pred <- merge(raster(interp_raster["var1.pred"]), raster(raster_crop_pred_avg))

  # apply filters
  for (i in seq_along(focal_types)) {
    sel_focal_type <- focal_types[i]
    sel_focal_d <- focal_d[[i]]
    sel_focal_raster_pred <- focal(raster_crop_pred, w=focalWeight(raster_crop_pred, sel_focal_d, sel_focal_type), na.rm=TRUE)

    # cut on borders ("buffer" value plus half of raster resolution, to cut pixels of border)
    crop_focal_raster_pred <- as(sel_focal_raster_pred,"SpatialGridDataFrame")[gBuffer(field_poly,width=-(border+globgrid@grid@cellsize[1]/2)),]

    # export raster
    subdir <- paste0("focal_",sel_focal_type,sel_focal_d,"x",sel_focal_d)
    dir.create(file.path(outdir,subdir), recursive=TRUE, showWarnings=FALSE)
    writeGDAL(crop_focal_raster_pred,file.path(outdir,subdir,outname), options='COMPRESS=DEFLATE')
  }
  # } # end of field_id cycle

}
